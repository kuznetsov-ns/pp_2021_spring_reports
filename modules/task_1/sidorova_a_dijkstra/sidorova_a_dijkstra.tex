\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\newenvironment{pseudocode}[1][htb]
  {\renewcommand{\algorithmcfname}{Алгоритм}
   \begin{algorithm}[#1]%
  }{\end{algorithm}}


\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\LargeПоиск кратчайших путей из одной вершины (алгоритм Дейкстры)} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381806-1 \\ Сидорова А.К.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
}

\vspace{\fill}

\begin{center} Нижний Новгород \\ 2021 \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Задача о кратчайшем пути в графе~--- это задача нахождения самого короткого пути между двумя вершинами графа, в которой минимизируется сумма весов рёбер, 
входящих в данный путь.  Задача о кратчайшем пути является одной из важнейших классических задач теории графов. Один из наиболее распространенных методов является алгоритм Дейкстры.
\par Алгоритм, созданный голландским ученым Эдсгером Дейкстра в 1959 году, находит все кратчайшие пути из одной изначально заданной вершины графа до всех остальных. 
С его помощью, при наличии всей необходимой информации, можно, например, узнать какую последовательность дорог лучше использовать, чтобы добраться наиболее 
быстро из одного города до каждого из многих других. Данный алгоритм работает только для графов без рёбер отрицательного веса. Поэтому если необходимо работать с графом, 
в котором есть отрицательные ребра, например, есть система с убыточными для некоторой фирмы маршрутами, то для работы с ней следует воспользоваться отличным от алгоритма Дейкстры методом.
\par В данной лабораторной работе будет рассмотрен метод Дейкстра для нахождения крайтчайших путей в графе с использованием различных технологий для выполнения параллельных вычислений.
\newpage

\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
В рамках лабораторной работы ставится задача разработки нескольких библиотек, реализующих алгоритм метода Дейкстра для нахождения кратчайших путей в графе.
\par В итоге программный комплекс должен поддерживать:
\begin{itemize}
\item Последовательный алгоритм метода Дейкстра;
\item Параллельные алгоритмы метода Дейкстра при помощи технологий OpenMP, TBB, std::threads;
\end{itemize}
\par Программное решение будет представлено следующим образом:
\begin{enumerate} 
\itemОтдельный модуль для каждой библиотеки, реализующей свою технологию для выполнения параллельных вычислений.
\itemНабор автоматических тестов с использованием Google C++ Testing Framework для каждой из технологий.
\end{enumerate} 
\newpage

\section*{Метод решения}
\addcontentsline{toc}{section}{Метод решения}
Пусть дан взвешенный неориентированный граф (в данной лабораторной работе обойдемся именно неориентированным графом) G(V, E), 
где V~--- множество вершин, E~--- множество ребер. Необходимо найти крайтчайшие пути от вершини root до всех остальных.
\par Каждой вершине из множества V сопоставим метку~--- была ли посещена данная вершина, и крайтшчайшее расстояние до вершины root 
(первоначально все вершины кроме root посещены, а все расстояние равный inf). На каждом шаге алгоритм сначала выбирает пройденную вершину (имеет положительную метку) с 
наикрайтчайшим расстоянием до root, назовем такую вершину текущей. Затем проходятся все непройденные, смежные с текущей вершины и, если расстояние от текущей вершины до смежной меньше, 
чем та имеет на данный момент, то расстояние перезаписывается. На этом шаг алгоритмы заканчивается. Работа же самого алгоритма завершается, когда все вершины посещены.
\par Приведем псевдокод данного алгоритма.
\begin{pseudocode}
\SetAlgoLined
\SetKwInOut{Input}{Вход}
\SetKwInOut{Output}{Выход}
\SetKwInOut{Data}{Данные}
\Input{граф $G(V,E)$; веса ребер $w(e)\geq 0, e \in E$; вершина-источник $root$}
\Output{расстояние $dist[v]$ от $root$ до каждой вершины $v \in V$; в начале $dist[v] = \infty$, для каждой $v \in V$ }
\Data{массив меток $mark[]$, $mark[v] = true $ - вершина $v$ посещена; в начале $mark[v] = false$ для каждой $v \in V$}
\BlankLine
\BlankLine
$dist[root] = 0$\;
$mark[root] = true$\;
\BlankLine
\For {$v \in V$} {
 $min = Min(dist[]): mark[min] == false$\;
 $mark[min] = true$\;
 \BlankLine
 \ForAll {вершин $k$, смежных с $min$} {
 	\If {$mark[k] == false\ \&\ dist[k] > dist[min] + w(min, k)$} {
  	$dist[k] = dist[min] + w(min, k)$\;
  } } }
\caption{Алгоритм Дейкстра}
\end{pseudocode}
\newpage

\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}
При данном алгоритме метода Дейкстра можно выделить два основных момента внутри главного обхода по всем вершинам графа:
\begin{itemize}
\item нахождение вершины с наименьшим расстоянием до root ~ O(n);
\item перезаписывание расстояний от root до всех непройденных вершин, которые являются смежными для найденной вершиной на предыдщуем этапе ~O(n);
\end{itemize}
\par Таким образом, на каждой итерации главного цикла по всем вершинам необходимо сначала распараллелить нахождение так называемого минимума, а затем
распараллелить участок кода, где происходит перезаписывание расстояний.
\newpage

\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Для удобства был введен отдельный класс для работы с графом. Под графом будем подразумевать матрицу расстояний.
\begin{lstlisting}
class Graph {
 public:
    explicit Graph(const std::vector<std::vector<size_t>>& distanceMatrix);
    explicit Graph(const size_t vertexCount = 10, const size_t edgeCount = 45);
    ~Graph() = default;

    std::vector<std::vector<size_t>> getDistanceMatrix() const;
    size_t getVertexCount() const;

    friend std::ostream& operator<<(std::ostream& out, const Graph& graph);
 private:
    void generate();

    size_t _vertexCount;
    size_t _edgeCount;
    std::vector<std::vector<size_t>> _distanceMatrix;
};
\end{lstlisting}
\par Теперь рассмотрим некоторые технические особенности для каждой из технологий для выполнения параллельных вычислений. Но  заметим, что функции, реализующие параллельный вариант метода Дейкстра при помощи различных технологий,  имеют единый вид для их вызова:
\begin{lstlisting}
std::vector<size_t> algorithmDijkstraParallel(const Graph& graph, const size_t root) { ... }
\end{lstlisting}
\par В качестве входных параметров передаются: граф и номер вершины, для которой необходимо найти все крайтчайшие пути.

\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}
Рассмотрим сначала распараллеливание алгоритма нахождения вершины с наименьшим расстоянием до root. Для этого была создана параллельная секция с помощью следующей директивы:
\par \verb|#pragma omp parallel firstprivate(minDistance, vertex)| 
\par Переменные minDistance, vertex с помощью параметра \verb|firstprivate| создаются локальными для каждого потока, а перед использованием инициализируются значениями исходных переменных. Внутри данной параллельной секции с помощью директивы \verb|#pragma omp parallel for| распараллеливается цикл нахождения вершины с наименьшим расстоянием до root. Таким образом, каждый свой поток найдет свою локальную вершину с минимальным расстоянием. Для того, чтобы найти глобальную вершину, то есть среди всех вершин, создается после критическая секция с помощью директивы \verb|#pragma omp critical|. В данную критичесую секцию каждый поток по очереди заходит, сравнивает свою локальную вершину с глобальной. В случае, когда локальная вершина имеет расстояние меньшее, чем у глобальной вершины, локальная вершина становится глобальной. Таким образом, в конце будет найдена общая для всех вершина, у которой самое короткое расстояние до root.
\par Для распараллеливания участка кода, в котором перезаписывались расстояния от root до всех непройденных вершин, которые являются смежными для найденной вершины на предыдщуем этапе, использовалась директива \verb|#pragma omp parallel for|, которая позволяет распараллеливать циклы \verb|for(...)|.

\subsection*{TBB}
\addcontentsline{toc}{subsection}{TBB}
Библиотека TBB предоставляет специальный инструмент для выполнения редукции \verb|tbb::parallel_reduce(...)|. Именно с помощью этого инструмента был распараллелен алгоритм нахождения вершины с наименьшим расстоянием до root. На вход необходимо подать \verb|tbb::blocked_range| ~--- рекурсивно делимый полуинтервал с указанными границами $[0; N)$, где $N$~--- количество вершин графа, вершину, которая имеет максимальное расстояние до root (в нашем случае \verb|UINT_MAX|), а также лямбда-функцию, которая производит вычисления над переданной ей порцией данных (нахождение локального минимума), и еще одну лямбда-функцию, позволяющую сравнивать между собой вершины по расстоянию от нее до root. Разделение на порции происходит планировщиком TBB автоматически.
\par Для распараллеливания участка кода, в котором перезаписывались расстояния от root до всех не пройденных еще вершин, которые являются смежными для найденной вершины на предыдущем этапе, использовался инструмент для распараллеливания циклов \verb|tbb::parallel_for(...)|. На вход подавать \verb|tbb::blocked_range| ~--- рекурсивно делимый полуинтервал с указанными границами $[0; N)$, где $N$~--- количество вершин графа.

\subsection*{std::threads}
\addcontentsline{toc}{subsection}{std::threads}
Для распараллеливания участка кода, в котором находится вершина с наименьшим расстоянием до root, использовалась оболочка \verb|std::future<>| над \verb|std::thread| и \verb|std::async|, позволяющие выполнять асинхронные вычисления в отдельных потоках. Для того, чтобы потоки работали действительно асинхронно, необходимо передать в \verb|std::async| первый параметр \verb|std::launch::deferred|. Затем после создания потоков, необходимо найти глобальный минимум из всех локальных минимумов, найденных каждым из потоков. Для этого создается цикл по \verb|std::future<>|, и с помощью метода \verb|get| получаем локальный результат выполнения определенного потока. На каждой итерации цикла сравниваем глобальный минимум и локальный, в случае, когда локальный оказался меньше глобального, мы перезаписываем глобальный максимум.


\newpage


\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности в программе представлен набор тестов, разработанных с помощью использования Google C++ Testing Framework.
\par Набор включает в себя следующие тесты, проверяющие корректность входных данных:
\begin{itemize}
\item создание графа с нулем вершин;
\item создание графа с помощью неквадратной матрицы расстояний размером;
\item создание графа с петлями;
\item создание графа $G(V,E)$, в котором $|E| >  \frac{|V| \times \left(|V| - 1\right)}{2}$;
\end{itemize}
 
\par А также тесты, проверяющие корретность вычислений:
\begin{itemize}
\item создание графа с помощью квадратной матрицы;
\item создание графа со случайными весами;
\item вычсиление расстояний для прописанного графа;
\item вычисление расстояний для неполного графа со случайными весами;
\item вычисление расстояний для полного графа со случайными весами.
\end{itemize}

\par Успешное прохождение всех тестов доказывает корректность работы системы.

\newpage

\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности алгоритма Дейкстра для нахождения крайтшайших путей в графе проводились на оборудовании со следующей аппаратной конфигурацией:

\begin{itemize}
\item Процессор: Intel Core i7-9750H, 2600 MHz, ядер: 6;
\item Оперативная память: 16 384 МБ (DDR4 SDRAM), 2667 MHz;
\item ОС: Microsoft Windows 10 Home, версия 20H2 сборка 19042.928.
\end{itemize}

\par Для проведения экспериментов был выбран полный граф с \verb|10 000| вершинами. 
\par Результаты экспериментов представлены в Таблице 1.

\begin{table}[!h]
\caption{Резултаты вычислительных экспериментов}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}
	{\begin{tabular}[c]{@{}c@{}}Кол-во\\ потоков\end{tabular}} & 
\multirow{2}{*}
	{\begin{tabular}[c]{@{}c@{}}Последовательный\\ алгоритм\end{tabular}} & 
\multicolumn{6}{c|}
	{Параллельный алгоритм}	\\ 
	\cline{3-8} & & 
	\multicolumn{2}{c|}{OpenMP} & 
	\multicolumn{2}{c|}{TBB} & 
	\multicolumn{2}{c|}{std::threads} 
	\\ \cline{2-8}
	& t, с	    & t, с & speedup		& t, с & speedup		& t, с & speedup		\\ \hline
2   & 0.72     & 0.58 & 1.24       	        & 0.69 & 1.04        	& 0.59 & 1.22           \\ \hline
4   & 0.72     & 0.55 & 1.30      	        & 0.62 & 1.16         	& 0.59  & 1.22         \\ \hline
8   & 0.72     & 0.52 & 1.38       	        & 0.61 & 1.18         	& 0.60  & 1.21        \\ \hline
\end{tabular}
\end{table}

\par По результатам экспериментов, можно сделать вывод о том, что параллельная реализация и правда работает быстрее, чем последовательная для всех технологий. При любом количестве потоков библиотека OpenMP показывала лучший результат. Скорее всего, инструмент TBB отстает по той причине, что у данного инструмента реализована своя работа с памятью, и возможно для алгоритмов, связанных с графами, данная библиотека не совсем подходит. По крайней мере, это видно в алгоритме Дейкстра. У std::thread результаты наблюдаются лучше, чем у TBB, но хуже чем у OpenMP. Это говорит о том, что у OpenMP есть свои оптимизации, позволяющие с наибольшей эффективностью использовать параллелизм.
\newpage


\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В результате данной лабораторной работы были разработаны несколько реализаций алгоритма Дейкстра для нахождения крайчайших путей в графе с использованием различных технологий, позволяющие выполнять параллельные вычисления: OpenMP, TBB, std::threads. А также были проведены эксперименты, благодаря которым удалось сделать вывод о том, что для алгоритма Дейкстра наиболее оптимальным инструментом для распараллеливания вычислений будет OpenMP
\par Кроме того, были разработаны тесты с использованием Google C++ Testing Framework, которые успешно проходят.
\newpage


\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{Sysoev} Сысоев А.В., Мееров И.Б., Свистунов А.Н., Курылев А.Л., Сенин А.В., Шишков А.В., Корняков К.В., Сиднев А.А. «Параллельное программирование в системах с общей памятью. Инструментальная поддержка». Учебно-методические материалы по программе повышения квалификации «Технологии высокопроизводительных вычислений для обеспечения учебного процесса и научных исследований». Нижний Новгород, 2007, 110 с. 
\bibitem{Wiki1} Wikipedia: the free encyclopedia [Электронный ресурс] // URL: https://en.wikipedia.org/wiki/ (дата обращения: 18.03.2021)
\bibitem{TBB} Intel® Threading Building Blocks Documentation [Электронный ресурс] // URL: https://software.intel.com/en-us/tbb-documentation (дата обращения: 1.04.2021)
\bibitem{cppreference} cppreference [Электронный ресурс] // https://en.cppreference.com/w/ (дата обращения: 21.04.2021)
\end{thebibliography}
\newpage

\end{document}