\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Сортировка Хоара с четно-нечетным слиянием Бэтчера.»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381806-2 \\ Пестреев Д. С.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2021 \end{center}

\end{titlepage}

\setcounter{page}{2}
\setcounter{page}{2}

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par
Достаточно часто при составлении программ на одном из этапов работы возникает задача
сортировки массива: требуется расположить его элементы по возрастанию или по убыванию.
Разработано множество алгоритмов её решения. Сортировка Хоара является одной из самых эффективных сортировок.
Алгоритм быстрой сортировки представляет собой усовершенствованный алгоритм, основанный на методике прямого обмена.
Главным и основным отличием быстрой сортировки является выполнение перестановок на самом большом, из возможных, расстоянии.
Но при увеличении объема данных скорость алгоритма уменьшается и время обработки может быть нерпиемлемо большим, в том числе и для алгоритма Хоара. 
Чтобы решить данную проблему, алгоритм сортировки можно сделать параллельным. 
Для этого исходные данные делятся на несколько массивов, сортируются последовательно и сливаются в один отсортированный массив. 
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Целью данной лабораторной работы является реализовать последовательный алгоритм быстрой сортировки и параллельный алгоритм быстрой сортировки с помощью четно-нечетного слияния Бэтчера.  Необходимо провести замеры времени работы алгоритмов и сделать выводы по полученным результатам.
\par Для параллельной реализации будут использоваться средства технологий OpenMP и TBB. Проверка алгоритмов на корректность будут осуществляться через Google C++ Testing Framework.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
Сначала полученнный массив делится на куски, количество которых равно числу потоков. Далее каждый кусок сортируется алгоритмом быстрой сортировки.
\par
Сортировка Хоара работает следующим образом:
\par 1. Найти элемент pivot в массиве. Стать им может каждый элемент в массиве. От выбора опорного элемента может зависеть производительность. В данной работе в качестве опорного алгоритма будет использоваться элемент по середине.
\par
2. Все элементы, которые меньше опорного, размещаем слева от него, а все, которые больше – справа.
\par
3. После одного прохода мы получаем массив, который отсортирован относительно опорного элемента. Все элементы левее опорного элемента меньше его, а все справа – больше.
\par
4. Чтобы завершить алгоритм, нужно представить, что части массива слева и справа от опорного элемента – это просто отдельные, ещё не отсортированные массивы, и поэтому их можно точно так же отсортировать, применив тот же самый алгоритм: выбрать опорный элемент и разделить массив ещё раз на 2 части. Затем повторить рекурсивно для каждой части и т.д.
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
Для распараллеливания необходимо разделить исходный массив на части, количество которых равно количеству потоков. Если невозможно разделить массив без остатка, добавляем в конец массива фиктивные переменные, которые больше всех элементов, то есть берется максимальное значение для данного типа данных. Потом распререляем их между потоками.
Каждая часть сортируется последовательной быстрой сортировкой.
\par Операции слияния отличаюся в OpenMP и TBB версиях.
\par В OpenMP реализации строится сеть обменной сортировки Бэтчера. Сеть строится из массива номеров потоков. Алгоритм построения сети заполняет массив компараторов, которые хранят пары номеров потоков. Сеть строится следующим образом:

\begin{enumerate}
\item Массив номеров потоков делится на 2 части;
\item Данные сегменты рекурсивно сливаются  по четным и нечетным элементам;
\item Записываем элементы в массив компараторов;
\item Рекурсивное повторение до тех пор, пока длина сегмента больше 1.
\end{enumerate}
\par После построения сети берутся пары потоков из массива компараторов. Каждый поток из пары берет свой фрагмент и фрагмент соседа. Далее происходит слияние так, что в одном потоке сохраняется массив с меньшими элементами, а в другом с большими. В итоге все части записываются в массив-результат в порядке номера потока.

\par TBB реализация использует рекурсивный алгоритм слияния. На каждом шаге массив делится на две части и для каждой части вызывается алгоритм.
Если размер порции меньше размера текущего фрагмента, вызываем последовательный алгоритм быстрой сортировки, иначе производим слияние по четным и нечетным элементам.

\newpage

% Программная реализация
\section*{Программная реализация}
\addcontentsline{toc}{section}{Программная реализация}

В течение лабораторной работы были написаны следующие методы и классы:
\par Функции, входящие в обе реализации:
\begin{lstlisting}
std::vector<int> getRandomVector(int size);
\end{lstlisting}
\par Данная функция возвращает случайно сгенерированный вектор заданной длины.

\begin{lstlisting}
void qsort(int* vec, int left, int right);
\end{lstlisting}
\par Данная функция реализует алгоритм быстрой сортировки. В качестве параметров получает массив значений, начальный и конечный индекс массива. В качестве pivot элемента берется элемент, индекс которого равен половине размера массива.

\begin{lstlisting}
std::vector<int> quickSortV(const std::vector<int>& vec);
\end{lstlisting}
\par Данная функция принимает константную ссылку на вектор, который нужно отсортировать. Из-за того, что значения входного вектора берутся по константной ссылке, нельзя реализовать для него рекуррентный алгоритм быстрой сортировки. Чтобы обойти это ограничение, значения вектора записываются в одномерный динамический массив и сортируются с помощью qsort. Полученный массив возвращается в виде вектора.

\par Функции, входящие в OpenMP реализацию:

\begin{lstlisting}
std::vector<std::vector<int>> div_into_part(const std::vector<int>& vec, int n) {
\end{lstlisting}
\par Данная функция принимает на вход одномерный вектор и делит его на n частей. Возвращает двумерный массив из данных фрагментов.

\begin{lstlisting}
void recur_merge(const std::vector<int>& left, const std::vector<int>& right);
\end{lstlisting}
\par Данная функция принимает константные ссылки на векторы, между которыми необходимо совершить слияние по четным и нечетным индексам, и заполняет массив компараторов. Вызывается в функции networking.

\begin{lstlisting}
void networking(const std::vector<int>& arr);
\end{lstlisting}
\par Данная функция принимает константную сслылку на вектор, содержащий номера потоков. Он делится пополам и для каждой половины вызывается функция recur\_merge.

\begin{lstlisting}
void batchers_network(int proc_size);
\end{lstlisting}
\par Функция принимает число потоков, создает вектор, заполненный индексами потоков и вызывает функцию networking.

\begin{lstlisting}
std::vector<int> parallel_sorting(const std::vector<int>& vec);
\end{lstlisting}
\par Функция принимает массив в виде ссылки на вектор, который нужно отсортировать. В функции реализована параллельная часть. Данные разделяются между потоками с помощью функции div\_into\_part и сортируются алгоритмом сортировки Хоара. Затем строится сеть Бэтчера. Далее берутся пары потоков из массива компараторов и сливаются части, хранящиеся в данных парах. Во время слияния расставлены барьеры, которые позволяют совершить работу всем потокам. После слияния части собираются в вектор, который является результатом.  

\par Функции и классы, входящие в TBB реализацию:

\begin{lstlisting}
class evenSplit;
\end{lstlisting}
\par Данный класс получает часть массива, размер части, размер фрагмента. В данном классе выполняется слияние элементов с четными индексами.

\begin{lstlisting}
class oddSplit;
\end{lstlisting}
\par Данный класс получает часть массива, размер части, размер фрагмента. В данном классе выполняется слияние элементов с нечетными индексами.

\begin{lstlisting}
class parallel_sorting;
\end{lstlisting}
\par Данный класс рекурсивно вызывает объект этого же класса, до тех пор, пока размер текущего фрагмента больше размера части, на которые делится исходный массив. Далее вызываются объекты класса evenSplit, oddSplit для четно-нечетного слияния. Вызываются потоки для параллельного выполнения слияния. Затем происходит сравнение четных и нечетных элементов. Если значение на четном месте меньше чем значение на нечетном, выполняется обмен.

\begin{lstlisting}
void parallel_sorting_int(int* mass, int size, int thread_size);
\end{lstlisting}
\par Данная функция получает одномерный массив, который нужно отсортировать, размер и количество потоков. Если массив не делится поровну на количество потоков, то дополняем его фиктивными переменными. Здесь вызывается объект класса parallel\_sorting, которому передается массив.

\begin{lstlisting}
bool CompareArrays(int* mas, int* Mas, int size);
\end{lstlisting}
\par Данная функция сравнивает два одномерных массива. Если они равны, возвращает true, иначе false.

\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности в программе представлен набор тестов, разработанных с помощью использования Google C++ Testing Framework.
\par Данные тесты проверяют корректность работы алгоритма(результаты работы сортировки последовательного и параллельного алгоритма сравниваются друг с другом) и эффективность параллельного алгоритма по сравнению с последовательным.

\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности параллельного алгоритма быстрой сортировки четно-нечетным слиянием Бэтчера производились на оборудовании со следующей аппаратной конфигурацией:

\begin{itemize}
\item Процессор: Intel(R) Core(TM) i3-6006U CPU @ 2.00 GHz, 2.00 GHz, 2 ядра, 4 потока;
\item Оперативная память: 16384 МБ (DDR4);
\item ОС: Microsoft Windows 10 Pro. 
\end{itemize}

\par Для эксперимента будем исспользовать вектор размера 42852314, заполненный случайными целыми числами. 
\par Результаты экспериментов в OpenMP версии:
\begin{table}[!h]
\caption{Результаты вычислительных экспериментов}
\centering
\begin{tabular}{lllll}
Кол-во потоков  & Последовательно & Параллельно \\
1      & 8.68401         & 9.69495  \\
2     & 8.33035         & 7.42786  \\
4     & 8.54299        & 5.89877 \\
6     & 8.85028        & 6.79795 \\
8     & 8.54013        & 8.0092

\end{tabular}
\end{table}

\par Результаты экспериментов в TBB версии:
\begin{table}[!h]
\caption{Результаты вычислительных экспериментов}
\centering
\begin{tabular}{lllll}
Кол-во потоков  & Последовательно & Параллельно \\
1      & 9.0003         & 9.01386  \\
2     & 8.97812         & 5.41781  \\
4     & 9.06282        & 5.0824 \\
6     &9.18621         & 4.05132 \\
8     & 8.92858        & 4.1427 \\

\end{tabular}
\end{table}

\par Полученные результаты говорят о том, что параллельный алгоритм работает быстрее последовательного. 
\par Для OpenMP версии при большом количестве потоков эффективность программы начинает падать. Это связано с большим количеством сравнений и издержками коллективных операциях приема и передачи данных.
\par Для TBB версии ухудшение наблюдается при 8 потоках. 
\par Для данной системы OpenMP версия будет работать наиболее эффективно при 4 потоках, а TBB версия при 6 потоках.
\newpage

% Вывод
\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
В результате выполнения лабораторной работы созданы последовательный алгоритм быстрой сортировки и параллельный с четно-нечетным слиянием Бэтчера в OpenMP и TBB версиях.
\par Результаты экспериментов говорят о том, параллельные алгоритмы работают эффективнее последовательной версии.
\par Также результаты экспериментов позволили сравнить время работы алгоритмов. Для того, чтобы подтвердить корректность работы программы был написан набор тестов Google C++
Testing Framework, которые были успешно пройдены.

\newpage

% Список литературы
\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{Hoare} 
Hoare C. A. R. Quicksort //The Computer Journal. – 1962. – Т. 5. – №. 1. – С. 10-16.
\bibitem{Gergel}
Гергель В. П. Теория и практика параллельных вычислений. – 2007. 
\bibitem{Gergel}
Гергель В. П., Стронгин Р. Г. Основы параллельных вычислений для многопроцессорных вычислительных систем. – 2003.
\bibitem{Habr} Сеть обменной сортировки со слиянием Бэтчера [Электронный ресурс] // URL: \url{https://habr.com/ru/post/275889/}
\end{thebibliography}
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
Данный раздел содержит весь код, написанный в рамках лабораторной работы.
\par Последовательная версия

\begin{lstlisting}
//  quick_sort_even_odd_merge.h

// Copyright 2021 Pestreev Daniil
#ifndef MODULES_TASK_1_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_
#define MODULES_TASK_1_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_

#include <vector>
#include <string>

std::vector<int> getRandomVector(int size);
void Swap(int a, int b);
void qsort(int* vec, int left, int right);
std::vector<int> quickSortV(const std::vector<int>& vec);

#endif  // MODULES_TASK_1_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_
\end{lstlisting}

\begin{lstlisting}
//  quick_sort_even_odd_merge.cpp

// Copyright 2021 Pestreev Daniil
#include <iostream>
#include <vector>
#include <random>
#include <limits>
#include <utility>
#include <ctime>
#include "../../../modules/task_1/pestreev_d_quick_sort_even_odd/quick_sort_even_odd_merge.h"

std::vector<int> getRandomVector(int size) {
    std::mt19937 gen;
    gen.seed(static_cast<unsigned int>(time(0)));
    std::vector<int> a(size);
    for (int i = 0; i < size; i++) {
        a[i] = gen();
    }
    return a;
}

void qsort(int* vec, int left, int right) {
    int mid;
    int l = left;
    int r = right;
    mid = vec[(l + r) / 2];
    do {
        while (vec[l] < mid) l++;
        while (vec[r] > mid) r--;
        if (l <= r) {
            std::swap(vec[l], vec[r]);
            l++;
            r--;
        }
    } while (l < r);
    if (left < r) qsort(vec, left, r);
    if (l < right) qsort(vec, l, right);
}

std::vector<int> quickSortV(const std::vector<int>& vec) {
    int size = vec.size();
    if (size <= 1) {
        return vec;
    }
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = vec[i];
    }
    qsort(arr, 0, size - 1);
    std::vector<int> tmp;
    for (int i = 0; i < size; i++) {
        tmp.push_back(arr[i]);
    }
    delete[] arr;
    return tmp;
}

\end{lstlisting}

\begin{lstlisting}
//  main.cpp

// Copyright 2021 Pestreev Daniil
#include <gtest/gtest.h>
#include <vector>
#include "./quick_sort_even_odd_merge.h"

TEST(Quick_Sort_Operations, Test_manual_vector) {
    std::vector<int> vec = {-8098, 1009, -160, -1, 179796, 2,
        -1603, 166, -7396, -19, -18348, -15, 659, 7, 82519};
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_random_vector_0) {
    std::vector<int> vec = getRandomVector(0);
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_random_vector_1) {
    std::vector<int> vec = getRandomVector(1);
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_sorted_vector) {
    std::vector<int> vec = getRandomVector(42211);
    std::sort(vec.begin(), vec.end());
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_inverted_sorted_vector42211) {
    std::vector<int> vec = getRandomVector(42211);
    std::sort(vec.begin(), vec.end(), [](int a, int b){
        return a > b;
    });
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_random_vector_42211) {
    std::vector<int> vec = getRandomVector(42211);
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}
TEST(Quick_Sort_Operations, Test_random_vector_3412211) {
    std::vector<int> vec = getRandomVector(3412211);
    std::vector<int> vec_V = quickSortV(vec);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}


int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}

\par OpenMP

\begin{lstlisting}
//  quick_sort_even_odd_merge.h

// Copyright 2021 Pestreev Daniil
#ifndef MODULES_TASK_2_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_
#define MODULES_TASK_2_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_

#include <omp.h>
#include <vector>
#include <string>

std::vector<int> getRandomVector(int size);
void Swap(int a, int b);
void qsort(int* vec, int left, int right);
std::vector<int> quickSortV(const std::vector<int>& vec);
void recur_merge(const std::vector<int>& left, const std::vector<int>& right);
void networking(const std::vector<int>& arr);
void batchers_network(int proc_size);
std::vector<std::vector<int>> div_into_part(const std::vector<int>& vec, int n);
std::vector<int> parallel_sorting(const std::vector<int>& vec, int thread_size);

#endif  // MODULES_TASK_2_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_
\end{lstlisting}

\begin{lstlisting}
//  quick_sort_even_odd_merge.cpp

// Copyright 2021 Pestreev Daniil

#include "../../../modules/task_2/pestreev_d_quick_sort_even_odd/quick_sort_even_odd_merge.h"

#include <omp.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <limits>
#include <utility>
#include <ctime>

std::vector<std::pair<int, int>> comps;

std::vector<int> getRandomVector(int size) {
    std::mt19937 gen;
    gen.seed(static_cast<unsigned int>(time(0)));
    std::vector<int> a(size);
    for (int i = 0; i < size; i++) {
        a[i] = gen();
    }
    return a;
}

void qsort(int* vec, int left, int right) {
    int mid;
    int l = left;
    int r = right;
    mid = vec[(l + r) / 2];
    do {
        while (vec[l] < mid) l++;
        while (vec[r] > mid) r--;
        if (l <= r) {
            std::swap(vec[l], vec[r]);
            l++;
            r--;
        }
    } while (l < r);
    if (left < r) qsort(vec, left, r);
    if (l < right) qsort(vec, l, right);
}

std::vector<int> quickSortV(const std::vector<int>& vec) {
    int size = vec.size();
    if (size <= 1) {
        return vec;
    }
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = vec[i];
    }
    qsort(arr, 0, size - 1);
    std::vector<int> tmp;
    for (int i = 0; i < size; i++) {
        tmp.push_back(arr[i]);
    }
    delete[] arr;
    return tmp;
}

std::vector<std::vector<int>> div_into_part(const std::vector<int>& vec,
    int n) {
    std::vector<std::vector<int>> res;
    int vec_size = vec.size();
    int part_len = vec_size / n;
    int delta = 0;
    for (int i = 0; i < n; i++) {
        std::vector<int> a;
        for (int j = delta; j < delta + part_len; j++) {
            a.push_back(vec[j]);
        }
        res.push_back(a);
        delta += part_len;
    }
    return res;
}

void recur_merge(const std::vector<int>& left, const std::vector<int>& right) {
    int array_count = left.size() + right.size();
    if (array_count <= 1) {
        return;
    }
    if (array_count == 2) {
        comps.push_back(std::pair<int, int>(left[0], right[0]));
        return;
    }
    std::vector<int> left_odd;
    std::vector<int> left_even;
    std::vector<int> right_odd;
    std::vector<int> right_even;
    int leftsize = left.size();
    for (int i = 0; i < leftsize; i++) {
        if (i % 2) {
            left_even.push_back(left[i]);
        } else {
            left_odd.push_back(left[i]);
        }
    }
    int rightsize = right.size();
    for (int i = 0; i < rightsize; i++) {
        if (i % 2) {
            right_even.push_back(right[i]);
        } else {
            right_odd.push_back(right[i]);
        }
    }

    recur_merge(left_odd, right_odd);
    recur_merge(left_even, right_even);

    std::vector<int> res;
    for (int i = 0; i < leftsize; i++) {
        res.push_back(left[i]);
    }
    for (int i = 0; i < rightsize; i++) {
        res.push_back(right[i]);
    }

    for (int i = 1; i + 1 < array_count; i += 2) {
        comps.push_back(std::pair<int, int>(res[i], res[i + 1]));
    }
}

void networking(const std::vector<int>& arr) {
    int arr_size = arr.size();

    if (arr_size <= 1) {
        return;
    }

    std::vector<int> l(arr.begin(), arr.begin() + arr_size / 2);
    std::vector<int> r(arr.begin() + arr_size / 2, arr.begin() + arr_size);
    networking(l);
    networking(r);
    recur_merge(l, r);
}

void batchers_network(int thread_size) {
    if (thread_size <= 1)
        return;
    std::vector<int> procs;
    for (int i = 0; i < thread_size; i++) {
        procs.push_back(i);
    }

    networking(procs);
}

std::vector<int> parallel_sorting(const std::vector<int>& vec,
    int thread_size) {
    std::vector<int> globalV = vec;
    int vecsizeG = globalV.size();

    if (thread_size < 0) {
        return globalV;
    }

    if (thread_size >= vecsizeG || thread_size == 1) {
        globalV = quickSortV(vec);
        return globalV;
    }
    int exitcircle = -1;
    int vecsizechange = 0;
    while (exitcircle < 0) {
        exitcircle = -1;
        if (globalV.size() % thread_size) {
            int o = std::numeric_limits<int>::max();
            vecsizechange++;
            globalV.push_back(o);
        } else {
            exitcircle = 1;
        }
    }
    vecsizeG = globalV.size();

    int vecsizeL = vecsizeG / thread_size;
    std::vector<std::vector<int>> loc = div_into_part(globalV, thread_size);
    batchers_network(thread_size);
    #pragma omp parallel for num_threads(thread_size)
    for (int i = 0; i < thread_size; i++) {
        const std::vector<int> v = loc[i];
        loc[i] = quickSortV(v);
        //  std::sort(loc[i].begin(), loc[i].end());
    }
#pragma omp barrier
    int comps_size = comps.size();

    #pragma omp parallel num_threads(thread_size)
    {
    for (int i = 0; i < comps_size; i++) {
        std::vector<int> localV(vecsizeL);
        std::vector<int> neighboringV(vecsizeL);
        std::vector<int> tmpV(vecsizeL);
        if (omp_get_thread_num() == comps[i].first) {
            localV = loc[omp_get_thread_num()];
            neighboringV = loc[comps[i].second];
            int localidx = 0;
            int neighboridx = 0;
            for (int tmp_index = 0; tmp_index < vecsizeL; tmp_index++) {
                int local = localV[localidx];
                int neighbor = neighboringV[neighboridx];
                if (local < neighbor) {
                    tmpV[tmp_index] = local;
                    localidx++;
                } else {
                    tmpV[tmp_index] = neighbor;
                    neighboridx++;
                }
            }
#pragma omp barrier
            loc[omp_get_thread_num()] = tmpV;
        } else if (omp_get_thread_num() == comps[i].second) {
            localV = loc[omp_get_thread_num()];
            neighboringV = loc[comps[i].first];
            int start = vecsizeL - 1;
            int localidx = start;
            int neighboridx = start;
            for (int tmp_index = start; tmp_index >= 0; tmp_index--) {
                int local = localV[localidx];
                int neighbor = neighboringV[neighboridx];
                if (local > neighbor) {
                    tmpV[tmp_index] = local;
                    localidx--;
                } else {
                    tmpV[tmp_index] = neighbor;
                    neighboridx--;
                }
            }
#pragma omp barrier
            loc[omp_get_thread_num()] = tmpV;
        } else if ((omp_get_thread_num() != comps[i].second)) {
            if ((omp_get_thread_num() != comps[i].first)) {
#pragma omp barrier
            }
        }
#pragma omp barrier
    }
    }
    std::vector<int> res;
    int size = thread_size;
    int size_m_s = vecsizeG / thread_size;
    for (int i = 0; i < size; i++)
    for (int j = 0; j < size_m_s; j++) {
        res.push_back(loc[i][j]);
    }
    if (vecsizechange > 0)
        res.erase(res.begin() + vecsizeG - vecsizechange,
            res.begin() + vecsizeG);
    return res;
}
\end{lstlisting}

\begin{lstlisting}
//  main.cpp

// Copyright 2021 Pestreev Daniil
#include <gtest/gtest.h>
#include <vector>
#include "./quick_sort_even_odd_merge.h"

TEST(Quick_Sort_Operations, Test_manual_vector) {
    std::vector<int> vec = {-8098, 1009, -160, -1, 179796, 2,
        -1603, 166, -7396, -19, -18348, -15, 7, 82519};
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_0_2) {
    std::vector<int> vec = getRandomVector(0);
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_0_4) {
    std::vector<int> vec = getRandomVector(0);
    std::vector<int> vec_V = parallel_sorting(vec, 4);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_1_2) {
    std::vector<int> vec = getRandomVector(1);
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_1_4) {
    std::vector<int> vec = getRandomVector(1);
    std::vector<int> vec_V = parallel_sorting(vec, 4);
    std::vector<int> vec_stan = vec;
    std::sort(vec_stan.begin(), vec_stan.end());
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_sorted_vector4231211_2) {
    std::vector<int> vec = getRandomVector(4231211);
    std::sort(vec.begin(), vec.end());
    double t1 = omp_get_wtime();
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    double t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--parallel" << std::endl;
    std::vector<int> vec_stan = vec;
    t1 = omp_get_wtime();
    std::sort(vec_stan.begin(), vec_stan.end());
    t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--seq" << std::endl;
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_inverted_sorted_vector4231211_2) {
    std::vector<int> vec = getRandomVector(4231211);
    std::sort(vec.begin(), vec.end(), [](int a, int b){
        return a > b;
    });
    double t1 = omp_get_wtime();
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    double t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--parallel" << std::endl;
    std::vector<int> vec_stan = vec;
    t1 = omp_get_wtime();
    std::sort(vec_stan.begin(), vec_stan.end());
    t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--seq" << std::endl;
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_1285231_2) {
    std::vector<int> vec = getRandomVector(1285231);
    double t1 = omp_get_wtime();
    std::vector<int> vec_V = parallel_sorting(vec, 2);
    double t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--parallel" << std::endl;
    std::vector<int> vec_stan = vec;
    t1 = omp_get_wtime();
    std::sort(vec_stan.begin(), vec_stan.end());
    t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--seq" << std::endl;
    ASSERT_EQ(vec_V, vec_stan);
}

TEST(Quick_Sort_Operations, Test_random_vector_12852314_4) {
    std::vector<int> vec = getRandomVector(12852314);
    double t1 = omp_get_wtime();
    std::vector<int> vec_V = parallel_sorting(vec, 4);
    double t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--parallel" << std::endl;
    std::vector<int> vec_stan = vec;
    t1 = omp_get_wtime();
    std::sort(vec_stan.begin(), vec_stan.end());
    t2 = omp_get_wtime() - t1;
    std::cout << t2 << "<--seq" << std::endl;
    ASSERT_EQ(vec_V, vec_stan);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}

\par TBB

\begin{lstlisting}
//  quick_sort_even_odd_merge.h

// Copyright 2021 Pestreev Daniil
#ifndef MODULES_TASK_3_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_
#define MODULES_TASK_3_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_

#include <vector>
int* getRandomArray(int size);
std::vector<int> getRandomVector(int size);
void Swap(int a, int b);
void qsort(int* vec, int left, int right);
std::vector<int> quickSortV(const std::vector<int>& vec);
class EvenSplitter;
class OddSplitter;
class parallel_sorting;
void parallel_sorting_int(int* inp, int size, int nThreads);

bool CompareArrays(int* mas, int* Mas, int size);

#endif  // MODULES_TASK_3_PESTREEV_D_QUICK_SORT_EVEN_ODD_QUICK_SORT_EVEN_ODD_MERGE_H_

\end{lstlisting}

\begin{lstlisting}
//  quick_sort_even_odd_merge.cpp

// Copyright 2021 Pestreev Daniil

#include "../../../modules/task_3/pestreev_d_quick_sort_even_odd/quick_sort_even_odd_merge.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <limits>
#include <utility>
#include <ctime>
#include "tbb/blocked_range.h"
#include "tbb/parallel_for.h"

int* getRandomArray(int size) {
    std::mt19937 gen;
    gen.seed(static_cast<unsigned int>(time(0)));
    int* a = new int[size];
    for (int i = 0; i < size; i++) {
        a[i] = gen();
    }
    return a;
}

void qsort(int* vec, int left, int right) {
    int mid;
    int l = left;
    int r = right;
    mid = vec[(l + r) / 2];
    do {
        while (vec[l] < mid) l++;
        while (vec[r] > mid) r--;
        if (l <= r) {
            std::swap(vec[l], vec[r]);
            l++;
            r--;
        }
    } while (l < r);
    if (left < r) qsort(vec, left, r);
    if (l < right) qsort(vec, l, right);
}

class evenSplit:public tbb::task {
 private:
    int *mass;
    int *mas_even;
    int size_mass;
    int size_mas_even;

 public:
    evenSplit(int *_mass, int *_mas_even, int _size_mass,
                int _size_mas_even): mass(_mass), mas_even(_mas_even),
                size_mass(_size_mass), size_mas_even(_size_mas_even)
    {}

    tbb::task* execute() {
        for (int i = 0; i < size_mass; i += 2)
            mas_even[i] = mass[i];
        int* other = new int[size_mass];
        for (int j = 0; j < size_mass; j++) {
            other[j] = mass[j + size_mass];
        }

        int a = 0;
        int b = 0;
        int i = 0;
        while ((a < size_mass) && (b < size_mas_even)) {
            if (mas_even[a] <= other[b]) {
                mass[i] = mas_even[a];
                a+=2;
            } else {
                mass[i] = other[b];
                b+=2;
            }
            i += 2;
        }

        if (a == size_mass) {
            for (int j = b; j < size_mas_even; j+=2, i+=2)
                mass[i] = other[j];
        } else {
            for (int j = a; j < size_mass; j+=2, i+=2)
                mass[i] = mas_even[j];
        }

        return NULL;
    }
};

class oddSplit:public tbb::task {
 private:
    int *mass;
    int *mas_odd;
    int size_mass;
    int size_mas_odd;

 public:
    oddSplit(int *_mass, int *_mas_odd, int _size_mass,
                int _size_mas_odd): mass(_mass), mas_odd(_mas_odd),
                size_mass(_size_mass), size_mas_odd(_size_mas_odd)
    {}

    tbb::task* execute() {
    for (int i = 1; i < size_mass; i+=2)
        mas_odd[i] = mass[i];

    int* other = new int[size_mass];
    for (int j = 0; j < size_mass; j++) {
        other[j] = mass[j + size_mass];
    }

    int a = 1;
    int b = 1;
    int i = 1;
    while ((a < size_mass) && (b < size_mas_odd)) {
        if (mas_odd[a] <= other[b]) {
            mass[i] = mas_odd[a];
            a+=2;
        } else {
            mass[i] = other[b];
            b+=2;
        }
        i += 2;
    }

    if (a == size_mass) {
    for (int j = b; j < size_mas_odd; j+=2, i+=2)
        mass[i] = other[j];
    } else {
    for (int j = a; j < size_mass; j+=2, i+=2)
        mass[i] = mas_odd[j];
    }

    return NULL;
    }
};

class parallel_sorting:public tbb::task {
 private:
    int *mas;
    int *tmp;
    int size;
    int part;

 public:
    parallel_sorting(int *_mas, int *_tmp, int _size,
        int _part): mas(_mas), tmp(_tmp),
        size(_size), part(_part)
    {}

    tbb::task* execute() {
        if (size <= part) {
        qsort(mas, 0, size - 1);
        } else {
        int s = size / 2 + (size/2)%2;

        parallel_sorting &sorter1 = *new (allocate_child())
                parallel_sorting(&mas[0], tmp, s, part);
        parallel_sorting &sorter2 = *new (allocate_child())
                parallel_sorting(&mas[s], tmp + s, size - s,
                                part);

        set_ref_count(3);

        spawn(sorter1);
        spawn_and_wait_for_all(sorter2);

        evenSplit &splitter1 = *new (allocate_child())
                evenSplit(&mas[0], tmp, s, size - s);
        oddSplit &splitter2 = *new (allocate_child())
                oddSplit(&mas[0], tmp, s, size - s);

        set_ref_count(3);

        spawn(splitter1);
        spawn_and_wait_for_all(splitter2);

        parallel_for(tbb::blocked_range<size_t>(1, (size+1)/2),
            [&](const tbb::blocked_range<size_t>& r) {
                for (size_t i = r.begin(); i < r.end(); i++)
                if (mas[2*i] < mas[2*i-1]) {
                    int _tmp = mas[2*i-1];
                    mas[2*i-1] = mas[2*i];
                    mas[2*i] = _tmp;
                }
            });
        }
        return NULL;
    }
};

void parallel_sorting_int(int* mass, int size, int thread_size) {
    if (size <= 1) {
        return;
    } else {
        int* mass_change;
        int* tmp = new int[size];
        int part = size / thread_size;
        bool change = false;
        if (size % thread_size != 0) {
        change = true;
            mass_change = new int[size + size % thread_size];
            for (int i = 0; i < size; i++) {
                mass_change[i] = mass[i];
            }
            for (int i = size; i < size % thread_size; i++) {
            int o = std::numeric_limits<int>::max();
            mass_change[i] = o;
            }
        }
        if (change) {
        parallel_sorting& sorter = *new (tbb::task::allocate_root())
            parallel_sorting(mass_change, tmp, size, part);
        tbb::task::spawn_root_and_wait(sorter);
        for (int i = 0; i < size; i++) {
            mass[i] = mass_change[i];
            }
            delete[] mass_change;
        } else {
            parallel_sorting& sorter = *new (tbb::task::allocate_root())
            parallel_sorting(mass, tmp, size, part);
        tbb::task::spawn_root_and_wait(sorter);
        }

        delete[] tmp;
    }
}

bool CompareArrays(int* mas, int* Mas, int size) {
    for (int i = 0; i < size; i++)
        if (mas[i] != Mas[i])
            return false;
    return true;
}

\end{lstlisting}

\begin{lstlisting}
//  main.cpp

// Copyright 2021 Pestreev Daniil
#include <gtest/gtest.h>
#include <vector>
#include "tbb/tbb.h"
#include "tbb/parallel_sort.h"
#include "./quick_sort_even_odd_merge.h"

TEST(pestreev_d_quick_sort_even_odd, Test_manual_array) {
    int size = 14;
    std::vector<int> vec = {-8098, 1009, -160, -1, 179796, 2,
        -1603, 166, -7396, -19, -18348, -15, 7, 82519};

    int* Array = new int[size];
    for (int i = 0; i < size; i++) {
        Array[i] = vec[i];
    }
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 2);
    for (int i = 0; i < size; i++) {
        std::cout << Array[i] << " ";
    }
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_random_array_0_2) {
    int size = 0;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 2);
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_random_array_0_4) {
    int size = 0;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 4);
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_random_array_1_2) {
    int size = 1;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 2);
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_random_array_1_4) {
    int size = 1;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 4);
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_random_array_100_4) {
    int size = 100;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }
    parallel_sorting_int(Array, size, 4);
    tbb::parallel_sort(Array_copy, Array_copy + size);
    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}

TEST(pestreev_d_quick_sort_even_odd, Test_sorted_vector4231211_2) {
    int size = 4231211;
    int* Array = getRandomArray(size);
    std::vector<int> vec;
    for (int i = 0; i < size; i++) {
        vec.push_back(Array[i]);
    }
    std::sort(vec.begin(), vec.end());
    parallel_sorting_int(Array, size, 2);
    std::vector<int> vec_s;
    for (int i = 0; i < size; i++) {
        vec_s.push_back(Array[i]);
    }
    ASSERT_EQ(vec, vec_s);
}

TEST(pestreev_d_quick_sort_even_odd, Test_inverted_sorted_vector4231211_2) {
    int size = 4231211;
    int* Array = getRandomArray(size);
    std::vector<int> vec;
    for (int i = 0; i < size; i++) {
        vec.push_back(Array[i]);
    }
    std::sort(vec.begin(), vec.end(), [](int a, int b){
        return a > b;
    });
    for (int i = 0; i < size; i++) {
        Array[i] = vec[i];
    }
    std::sort(vec.begin(), vec.end());
    parallel_sorting_int(Array, size, 2);
    std::vector<int> vec_s;
    for (int i = 0; i < size; i++) {
        vec_s.push_back(Array[i]);
    }
    ASSERT_EQ(vec, vec_s);
}

TEST(pestreev_d_quick_sort_even_odd, Test_on_35500000_tbbsort) {
    int size = 35500000;
    int* Array = getRandomArray(size);
    int* Array_copy = new int[size];
    for (int i = 0; i < size; i++) {
        Array_copy[i] = Array[i];
    }

    tbb::tick_count b1 = tbb::tick_count::now();
    parallel_sorting_int(Array, size, 4);
    tbb::tick_count e1 = tbb::tick_count::now();

    double time1 = (e1 - b1).seconds();
    std::cout << "parallelBatcher-> " << time1 << std::endl;

    tbb::tick_count b2 = tbb::tick_count::now();
    qsort(Array_copy, 0, size - 1);
    tbb::tick_count e2 = tbb::tick_count::now();

    double time2 = (e2 - b2).seconds();
    std::cout << "seqBatcher-> " << time2 << std::endl;

    ASSERT_EQ(1, CompareArrays(Array, Array_copy, size));
}


int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}

\end{document}